name: Build and Release

on:
  push:
    tags:
      - 'v*' # 触发条件：当一个以 'v' 开头的标签被推送时

jobs:
  create-release:
    runs-on: ubuntu-latest
    outputs:
      upload_url: ${{ steps.create_release.outputs.upload_url }}
    permissions:
      contents: write
    steps:
      - name: Create Release
        id: create_release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ github.ref_name }}
          release_name: Release ${{ github.ref_name }}
          draft: false
          prerelease: false

  build-and-upload:
    needs: create-release # 确保 release 创建后再执行构建和上传
    strategy:
      matrix:
        include:
          # - os: ubuntu-latest
          #   goos: linux
          #   goarch: amd64
          #   asset_name_suffix: ""
          #   rust_target: x86_64-unknown-linux-gnu
          # - os: ubuntu-latest
          #   goos: linux
          #   goarch: arm64
          #   asset_name_suffix: ""
          #   rust_target: aarch64-unknown-linux-gnu
          - os: macos-latest
            goos: darwin
            goarch: amd64
            asset_name_suffix: ""
            rust_target: x86_64-apple-darwin
          - os: macos-latest
            goos: darwin
            goarch: arm64
            asset_name_suffix: ""
            rust_target: aarch64-apple-darwin
          - os: windows-latest
            goos: windows
            goarch: amd64
            asset_name_suffix: .exe
            rust_target: x86_64-pc-windows-gnu
          # Windows ARM64 is more complex to set up for Rust cross-compilation, skipping for now.
          # - os: windows-latest
          #   goos: windows
          #   goarch: arm64
          #   asset_name_suffix: .exe
          #   rust_target: aarch64-pc-windows-msvc # or gnu
    runs-on: ${{ matrix.os }}
    permissions:
      contents: write # 需要写入权限来上传 release assets

    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          lfs: true

      - name: Set UTF-8 Locale
        run: |
          echo "LANG=en_US.UTF-8" >> $GITHUB_ENV
          echo "LC_ALL=en_US.UTF-8" >> $GITHUB_ENV
          echo "LANGUAGE=en_US.UTF-8" >> $GITHUB_ENV
        shell: bash

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: '1.21'

      - name: Install Rust toolchain
        uses: dtolnay/rust-toolchain@stable
        with:
          toolchain: stable
          targets: ${{ matrix.rust_target }} # Ensure the target for cross-compilation is installed

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.x'

      - name: Install Python dependencies
        run: pip install requests

      - name: Run download_onnxruntime.py
        run: python download_onnxruntime.py
        # IMPORTANT: This script (located at backend/Go/Git/download_onnxruntime.py) MUST correctly
        # download and place libraries for the specific GOOS/GOARCH into the paths expected by the
        # Makefile (backend/Go/Git/Makefile).
        # It should NOT download libtokenizers.a as we are building it from source.

      - name: Build tokenizers library
        shell: bash
        run: |
          set -e # Exit immediately if a command exits with a non-zero status.
          echo "Building tokenizer for GOOS=${{ matrix.goos }}, GOARCH=${{ matrix.goarch }}, RUST_TARGET=${{ matrix.rust_target }}"

          TOKENIZERS_REPO_DIR=../tokenizers_src_temp # Temporary directory for cloning

          echo "Cloning daulet/tokenizers..."
          git clone --depth 1 https://github.com/daulet/tokenizers.git $TOKENIZERS_REPO_DIR
          cd $TOKENIZERS_REPO_DIR

          echo "Building libtokenizers with Cargo for target ${{ matrix.rust_target }}..."
          cargo build --release --target ${{ matrix.rust_target }}

          # Determine the correct library file extension and name based on target
          if [[ "${{ matrix.goos }}" == "windows" ]]; then
            LIB_EXTENSION="lib"
            LIB_PREFIX=""
            SOURCE_LIB_NAME="tokenizers.lib"
          else
            LIB_EXTENSION="a"
            LIB_PREFIX="lib"
            SOURCE_LIB_NAME="libtokenizers.a"
          fi

          SOURCE_LIB_PATH="target/${{ matrix.rust_target }}/release/${SOURCE_LIB_NAME}"
          DEST_DIR="${{ github.workspace }}/libtokenizers/${{ matrix.goos }}_${{ matrix.goarch }}"
          DEST_LIB_PATH="$DEST_DIR/${SOURCE_LIB_NAME}"

          echo "Source library path: $SOURCE_LIB_PATH"
          echo "Destination directory: $DEST_DIR"

          # Check for alternative library names if the primary one doesn't exist
          if [ ! -f "$SOURCE_LIB_PATH" ]; then
            echo "Primary library not found, checking alternatives..."
            if [[ "${{ matrix.goos }}" == "windows" ]]; then
              # Try .lib and .a extensions for Windows
              for alt_name in "libtokenizers.lib" "tokenizers.lib" "libtokenizers.a"; do
                alt_path="target/${{ matrix.rust_target }}/release/${alt_name}"
                if [ -f "$alt_path" ]; then
                  SOURCE_LIB_PATH="$alt_path"
                  SOURCE_LIB_NAME="$alt_name"
                  DEST_LIB_PATH="$DEST_DIR/${alt_name}"
                  echo "Found alternative: $SOURCE_LIB_PATH"
                  break
                fi
              done
            fi
          fi

          if [ ! -f "$SOURCE_LIB_PATH" ]; then
            echo "Build failed: No suitable library found!"
            echo "Contents of target/${{ matrix.rust_target }}/release/:"
            ls -la "target/${{ matrix.rust_target }}/release/" || echo "Directory not found"
            exit 1
          fi

          echo "Creating destination directory: $DEST_DIR"
          mkdir -p "$DEST_DIR"

          echo "Copying $SOURCE_LIB_PATH to $DEST_LIB_PATH"
          cp "$SOURCE_LIB_PATH" "$DEST_LIB_PATH"

          echo "Successfully built and copied ${SOURCE_LIB_NAME}"
          cd ../.. # Return to original directory or a known base for next steps

      # Windows specific setup for CGO
      - name: Setup MinGW (Windows)
        if: matrix.goos == 'windows'
        shell: bash
        run: |
          echo "Installing MinGW-w64 via chocolatey..."
          choco install mingw -y --no-progress

          # Add MinGW to PATH for this session
          export PATH="/c/ProgramData/chocolatey/lib/mingw/tools/install/mingw64/bin:$PATH"
          echo "/c/ProgramData/chocolatey/lib/mingw/tools/install/mingw64/bin" >> $GITHUB_PATH

          # Verify installation
          echo "Verifying MinGW installation..."
          gcc --version || echo "GCC not found in PATH"
          which gcc || echo "GCC location not found"

      - name: Verify build environment
        shell: bash
        run: |
          echo "=== Build Environment Verification ==="
          echo "OS: ${{ matrix.os }}"
          echo "GOOS: ${{ matrix.goos }}"
          echo "GOARCH: ${{ matrix.goarch }}"
          echo "Rust target: ${{ matrix.rust_target }}"

          echo "Go version:"
          go version

          echo "CGO environment:"
          go env CGO_ENABLED

          if [[ "${{ matrix.goos }}" == "windows" ]]; then
            echo "Windows-specific checks:"
            echo "GCC version:"
            gcc --version || echo "GCC not found"
            echo "MinGW location:"
            which gcc || echo "GCC not in PATH"
          fi

          echo "Checking required directories:"
          ls -la ./libtokenizers/${{ matrix.goos }}_${{ matrix.goarch }}/ || echo "Tokenizers directory not found"
          ls -la ./onnxruntime/ || echo "ONNX Runtime directory not found"

      - name: Get CGO_LDFLAGS (Unix-like)
        if: matrix.os != 'windows-latest'
        id: cgo_ldflags_unix
        run: |
          LDFLAGS_VALUE=$(make -s print-cgo-ldflags)
          echo "Extracted CGO_LDFLAGS: $LDFLAGS_VALUE"
          echo "cgo_ldflags_value=$LDFLAGS_VALUE" >> $GITHUB_OUTPUT
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}

      - name: Get CGO_LDFLAGS (Windows)
        if: matrix.os == 'windows-latest'
        id: cgo_ldflags_windows
        shell: bash
        run: |
          LDFLAGS_VALUE=$(make -s print-cgo-ldflags)
          echo "Original CGO_LDFLAGS from make: $LDFLAGS_VALUE"
          # Remove problematic flags for Windows
          LDFLAGS_VALUE_CLEANED=$(echo "$LDFLAGS_VALUE" | sed 's/-ldl//g' | sed 's/--exclude-libs,dl//g' | sed 's/  */ /g' | sed 's/^ *//' | sed 's/ *$//')
          echo "Cleaned CGO_LDFLAGS: $LDFLAGS_VALUE_CLEANED"
          echo "cgo_ldflags_value=$LDFLAGS_VALUE_CLEANED" >> $GITHUB_OUTPUT
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}

      - name: Build application for ${{ matrix.goos }}/${{ matrix.goarch }}
        shell: bash
        run: |
          if [ "${{ matrix.goos }}" == "windows" ]; then
            # For Windows, create a simple wrapper to handle the build
            echo "Building Windows application with special handling..."
            mkdir -p bin
            # Use go build directly with filtered environment
            export GOOS=windows
            export GOARCH=amd64
            export CGO_ENABLED=1
            export CC=gcc
            # Build without problematic flags
            go build -v -o bin/MathReX-windows-amd64.exe ./
          elif [ "${{ matrix.goos }}" == "darwin" ]; then
            make build-macos-app
          else
            make build
          fi
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
          MACOSX_DEPLOYMENT_TARGET: ${{ matrix.goos == 'darwin' && '10.15' || '' }}
          CGO_ENABLED: 1
          CGO_LDFLAGS: ${{ (matrix.os != 'windows-latest' && steps.cgo_ldflags_unix.outputs.cgo_ldflags_value) || '-L./libtokenizers/windows_amd64/' }}

      - name: Add executable permissions (Linux/non-App macOS)
        if: (matrix.goos == 'linux') || (matrix.goos == 'darwin' && matrix.asset_name_suffix != '.zip')
        run: chmod +x bin/MathReX-${{ matrix.goos }}-${{ matrix.goarch }}

      - name: Package macOS .app into a .zip
        if: matrix.goos == 'darwin'
        run: |
          cd bin
          zip -r MathReX-${{ matrix.goos }}-${{ matrix.goarch }}.zip MathReX.app
          cd ..
        # The asset_name_suffix for darwin should now reflect .zip

      - name: Upload Release Asset
        uses: actions/upload-release-asset@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ needs.create-release.outputs.upload_url }}
          asset_path: ${{ matrix.goos == 'darwin' && format('bin/MathReX-{0}-{1}.zip', matrix.goos, matrix.goarch) || format('bin/MathReX-{0}-{1}{2}', matrix.goos, matrix.goarch, matrix.asset_name_suffix) }}
          asset_name: ${{ matrix.goos == 'darwin' && format('MathReX-{0}-{1}.app.zip', matrix.goos, matrix.goarch) || format('MathReX-{0}-{1}{2}', matrix.goos, matrix.goarch, matrix.asset_name_suffix) }}
          asset_content_type: ${{ matrix.goos == 'darwin' && 'application/zip' || 'application/octet-stream' }}
